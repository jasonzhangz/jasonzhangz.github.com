<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2020%2F03%2F12%2Fredis%2F</url>
    <content type="text"><![CDATA[缓存经典架构 缓存中间件 - Memcache 和 Redis的区别 Memcache 代码层次类似Hash 支持简单的数据类型 不支持数据持久化存储 不支持主从同步 不支持分片 Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。 数据结构简单，对数据操作也简单 采用单线程，单线程也能处理高并发请求，可启动多实例，构建集群 使用多路I/O复用模型，非阻塞IO 多路复用模型 传统的阻塞I/O模型，如果文件不可以，则会一直阻塞中，这样就导致，其他的读写操作被等待 在linux中，select方法可以同时监控多个文件描述符的可读可写 情况，当某些文件描述符可读或者可写的时候，select方法就会返回可读可写的文件描述符的个数 Redis采用的是I/O多路复用函数： epoll/kqueue/evport/select? 因地制宜，根据编译平台的不同，选用不同的函数，提供给上层应用统一的接口 优先选择时间复杂度为O(1)的I/o多路复用函数作为底层实现 linux - epoll , mac - kqueque 等 以时间复杂度为O(n)的select作为保底，会扫描全部的文件描述符，时间复杂度差 基于react设计模式监听I/O事件 Redis的数据类型 String：最基本的数据类型，二进制安全（可以包含任何数据，如图片，序列化的对象）。最大可存储512M String 的底层是简单动态字符串 sds 其他涉及的底层数据结构链表 字典 跳跃表 数据集合 压缩列表 对象 Hash：String元素组成的字典，适合用于存储对象 hmset hget List：列表，按照String元素插入顺序排序（后进先出 大约40亿个成员 最新消息排行榜） lpush lrange Set : String 元素组成的无序集合，通过哈希表实现，不允许重复(微博中关注人，粉丝存在于集合中 共同关注，喜好等功能 交集 并集 叉集 ) sadd smembers Sorted Set ： 通过分数来给集合中的成员进行从小到大的排序，不重复，每个成员都会关联一个double的分数，通过这个分数来排序 zadd zrangebyscore 用于计数的HyperLog，用于支持存储地理位置信息的Geo 从海量Key里面查询出某一固定的前缀的Key KEYS pattern： 查找所有符合给定模式pattern的key。一次性返回所有匹配的key，如果key的数据量过大，会使服务卡顿 ，可能会对线上业务产生影响，可能会阻塞服务 SCAN cursor [MATCH pattern] [COUNT count] : 无阻塞的提取出指定模式的key列表，返回少量元素，可以用于生产环境 如何通过Redis实现分布式锁分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁的实现，当不同系统访问共享资源的时候，需要通过互斥的方式，保证一致性。 分布式锁需要解决的问题 互斥性，任意时刻只能有一个客户端获取锁 安全性，锁只能被持有该锁的客户端删除 死锁，持有锁的某些客户端因为某些原因宕机而无法正常释放锁，导致其他客户端无法获取到该锁，提供相应机制 容错，当部分节点宕机的时候，客户端依然能够获取锁和释放锁 实现分布式锁原理在执行业务代码前，先执行SETNX指令，根据返回值，确定key是否插入，若为插入循环调用；若插入成功，则当当前key设置过期时间，同时执行业务代码 SETNX key value : 如果key不存在，则创建并赋值，操作是原子的 时间复杂度为：O(1) 返回值：设置成功，返回1；设置失败，返回0 EXPIRE key seconds ： 操作是原子的 设置key的生存时间，当key过期时（生存时间为0），会被自动删除 伪代码 一123456789@AutoWiredRedisServie redisService long status = redisService.setnx(key, "1");if (status == 1) &#123; redisService.expire(key, expire); // do something doSomeThing();&#125; 上述伪代码可能产生问题。当代码执行4行结束，程序挂了，那么当前的key就会被一直占用，意味着其他线程就无法得到独占的资源。 产生这种的原因就是：原子性得不到满足。SETNX 和EXPIRE 操作是原子性的，但是这两个操作的组合是原子性的 为了解决上述产生的问题，redis在2.6.12，版本以后可以通过 SET指令将SETNX 和EXPIRE 操作融合在一起，这个整体是原子性操作。 SET key value [EX seconds] [PX milliseconds] [NX|XX] EX seconds : 设置键的过期时间为second 秒 PX milliseconds ： 设置键的过期时间为milliseconds毫秒 NX：只在键不存在时，才对键进行设置操作 等同于SETNX XX：只在键已存在时，才对键进行设置操作 等同于SETNX SET 操作完成时，返回ok，否则返回nil 伪代码 二12345678@AutoWiredRedisServie redisService String res = redisServic.set(lockKey,"NX","ex",10);if ("Ok".equals(res)) &#123; // do something doSomeThing();&#125; 大量的key同时过期的注意事项 集中过期，由于需要清除大量的key很耗时，所以会出现暂时的卡顿现象 解决方案：在设置key的过期时间的时候，给每个key加上随机值 如何使用Redis做异步队列使用List作为队列，RPUSH生产消息，LPOP消费消息 缺陷：没有等待队列里有值就直接消费；一个消息只能被一个客户端消费一次 优化 可以通过在应用层引入sleep机制去调用LPOP重试 可以使用BLPOP key timeout 阻塞直到队列有消息或者超时 ，只能被消费一次 pub/sub：主题订阅者模式 发送者（pub）发送消息，订阅者（sub）接收消息 订阅者可以订阅任意数量的频道（topic） 优点：pub/sub能实现一条消息被N个消费者消费，同时可以使消费者只关注自己订阅的频道的数据 缺点：消息的发布是无状态的，无法保证可达，无法保证在传输过程中消息是否丢失。对于发布者来说，消息是即发即失，也就是说，如果在发布者在发布消息到指定的频道时，恰巧订阅了当前频道的消费者下线了，那么在这个消费者重新上线以后，是接收不到该消息了。解决此类问题，需要使用专业的消息队列 kafka mq中间件 Redis如何做持久化方式一： RDB-快照持久化，保存某个时间点的全量数据快照，设置redis.conf文件1234567save "" #禁用rdb操作save 900 1 #after 900 sec (15 min) if at least 1 key changedsave 300 10 #after 300 sec (5 min) if at least 10 key changedsave 60 10000 #after 60 sec (1 min) if at least 10000 key changedstop-writes-on-bgsave-error yes #当备份进程出错的时候，主进程就停止接收新的写入操作，保证持久化的一致性问题rdbcompression yes #备份的时候将rdb文件进行压缩，建议设置成no，因为设置成yes会带来消耗 SAVE： 阻塞Redis的服务进程，直到RDB文件被创建完毕。由于redis单线程模型，所以会阻塞所有客户端的请求。 BGSAGE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程。 自动化触发RDB持久化的方式 根据redis.conf 配置里的SAVE m n 定时触发（用的是BGSAVE） 主从复制，主节点自动触发 执行Debug Reload 执行Shutdown 且没有开启AOF持久化 RDB方式存在缺点 内存数据是全量同步，数量大会由于I/O而严重影响性能 可能会因为Redis挂掉而丢失从前至最近一次快照期间的数据 方式二 AOF（Append-Only-File）持久化：保存写状态AOF会记录下除了查询以外的所有变更数据库状态的指令，以append的形式追加保存到AOF文件中(增量)，实时性会更好，因此已成为主流的持久化方案。默认未开启AOF，在redis.conf文件中设置appendonly开启，默认文件是src\appendonly.aof 1appendonly yes 在Redis的配置文件中存在三种不同的 AOF 持久化方式 123appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘，推荐方式速度，安全appendfsync no #让操作系统决定何时进行同步，默认操作系统把缓存区填满才开始同步 数据恢复对于RDB和AOF文件共存情况下的恢复流程 RDB和AOF的优缺点 RDB 优点：全量数据快照，文件小，恢复快 缺点：无法保存最近一次快照之后的数据 AOF 优点：可读性高，适合保存增量数据，数据不容易丢失 缺点：文件体积大，恢复时间长 Redis 4.0 对于持久化机制的优化（结合AOF和RDB的互补）Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。 如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试-redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原子类Atomic]]></title>
    <url>%2F2020%2F03%2F10%2FAtomic%2F</url>
    <content type="text"><![CDATA[什么是原子类，有什么用指的是某个操作不可分割，具有原子性 6类原子类纵览 Atomic*基本类型原子类 以AtomicInteger为例 Atomic*Array数组原子类 Atomic*Reference引用型原子类 把普通变量升级为原子类：AtomicIntegerFieldUpdater升级原有变量]]></content>
      <tags>
        <tag>JUC-Atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql摘要]]></title>
    <url>%2F2019%2F07%2F18%2Fmysql%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[读写锁当多个查询要在同一时刻修改数据的时候，就会产生并发控制的问题。 mysql的并发控制主要体现在两个方面：服务器层与存储引擎层 并发控制一种形式有效的方式就是通过锁机制，即对于每一个查询都会通过锁来方式数据损坏，如果另外一个查询试图修改正在访问的数据时候，那就必须等待锁释放以后。 但是这样的处理方案又产生一个问题，那么在同一时刻只有一个查询能够获得锁，在高并发的场景下，显示不合理。 基于上面所产生的问题，一种经典的处理方案产生，可以通过两种类型的锁。 共享锁（读锁）：互不阻塞。多个客户在同一时刻可以同时读取同一资源，互补干扰。（查询） 排他锁（写锁）：一个写锁会阻塞其他的读锁和写锁。保证了在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。（插入，删除，更新） 锁粒度提供共享资源并发性的方式就是让锁定对象更有选择性，即尽量只锁定需要修改的部分数据，而不是所有资源。 更理想的方式，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。 大家都知道锁机制是需要消耗资源的。如获的锁、检查锁释放已经解除、释放锁等。如果锁管理消耗的资源越多，那么数据库的性能会因此而受到影响 锁策略 就是在锁的开销和数据的安全性之间寻找平衡，这种平衡会影响到性能。 目前比较常用的锁策略：表锁（table lock） 和 行级锁（row lock） 表锁 顾名思义锁定整张表。 开销最小。一个用户在对表执行写操作（插入、删除、更新等）之前，需要先获取写锁，这将导致阻塞其他用户对该表的所有读写操作。相反，只要没有写锁，其他读取的用户才能获得读锁，读锁互相不阻塞。 需要注意的是：写锁比读锁的优先级高，因此一个写锁请求可能会被插入到读锁队列的前面，反之不可以。 行级锁 锁定锁定具体操作行。行级锁可以最大程度支持并发处理，同时开销也大。行级锁值在存储引擎层实现，而在mysql服务器 层没有实现。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成都之行-Redspider社区第一次完整线下聚会]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%88%90%E9%83%BD%E4%B9%8B%E8%A1%8C-Redspider%E7%A4%BE%E5%8C%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%BA%BF%E4%B8%8B%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[相识说起认识，17年毕业工作以后就出差去成都了，从17年的8月到18年的3月，也是机缘巧合加了一个招聘群。大家彼此都不认识，对于人多的群，想必大家也都知道，总有那么几个爱闹，比较活跃，容易开车的人，我就其中的一个，曾经群里有组织线下聚会，虽然自己很想参加，无奈项目比较紧张，所以也就没去，比较遗憾 - _ - ! 慢慢熟悉了以后，最初是认识的人是七叔，一个充满喜感的人，因为群里的备注这样，同样也是他自己博客的名，就这样叫习惯了，甚至在第一次见面的时候我甚至想不起来他的真实名字，是不是有点尴尬。在群里得知七叔就职于ThoughtWorks，不过是在成都。当时的我也有想法投西安的ThoughtWorks的相关岗位。也是基于此，我加了七叔的微信，就此认识了。平时主要还是沟通技术方面的内容，如何学习技术、如何提升自己、如何面试等 志同道合具体哪一天我已经忘记了，只是记得七叔和我聊天说，自己和几个人组织了一个小的社区，其目的就是：共同学习，互相督促，形成产出，每日打卡。原因很简单，我就加入了小小的学习社区，加上我一共五个人。 陈sir、七叔、杨指导、卢指导，张指导(我) 在这里我们制定一个共同的学习知识点，目前已经共同的学习有：Java并发、JVM、集合等Java相关基础知识。 也尝试做一些基于业界直流技术 sping boot 、sping cloud 、vue等项目 就这样我们经过自己共同努力，陈sir完成了完美的跳槽，进入大佬级别 社区地址：RedSpider 我们采用敏捷的模式，每周都会进行一次迭代会，对上一周工作总结，对下一周工作的安排：迭代会议 难得一次的线下相聚每周末我们都会通过线上的方式进行会议沟通，学习等。因为我西安，而他们都在成都，所以大伙非常照顾我，他们几个线下，开启语音，就这样我们一起学习，督促，进步。 曾经以为自己的自我学习能力和自我驱动能力很强，但是在深入的和大家接触了以后，发现优秀的人真的都是自律的，相比其他人，自己还需要跟多的自律，更多的努力。 在我决定离职的时候，大伙儿都直言不讳的给我最真实的建议。这或许就是所谓的诤友，我很庆幸在这个年纪遇到了大家。也是因为这次离职我难得有相对充裕的时间，因为决定和大家线下真实聚一下，这是大型的面基啊 ~ 在一起我们畅聊所有，对未来，对职业规划，关于结婚，关于房子。。。 在以后我们任然会定时打卡，共同进步 ~ 感谢在最好的年纪遇见你们 ~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（1）- 概述]]></title>
    <url>%2F2019%2F06%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是设计模式设计模式：对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。 一个设计模式命名、抽象和确定了一个通用设计结构的主要方面，这些设计结构能被用来构造可复用的面向对象设计。设计模式确定了锁包含的类和实例，他们的角色、协作方式以及职责分配。 一个设计模式包含四个基本元素： 模式名称 一个助记名，用一两个词来描述模式的问题、解决方案、效果。 问题 描述应该在何时使用模式。它节水了设计问题和问题存在的前因后果，可能描述了特定的设计问题，如怎样用对象表示算法。 解决方案 描述设计的组成成分，他们之间的相互关系及各自的职责和协作方式。 效果 描述模式应用后的效果及使用模式应权衡的问题。软件效果大多关注对时间和空间的衡量。这里的效果包括了它系统的灵活性、扩展性、可移植性的影响。 23中设计模式目的 名称 描述 描述 1 Abstract Factory 抽象工厂模式 提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们的具体 2 Adapter 适配器 将一个类的接口转换成客户希望的另外一个接口。此模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 3 Bridge 桥接 将抽象部分与它的实现部分分离，使它们都可以独立地变化 4 Builder 建造者 将一个复杂对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示 5 Chain of Responsibility 责任链 为了解除请求的发送者与接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传播该请求，直到有一个对象处理它。 6 Command 命令行 将一个请求封装成为一个对象，从而使你可以用不同的请求对客户的请求进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 7 Composite 组合 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对耽搁对象和复合对象的使用具有一致性。 8 Decorator 装饰 动态的给一个对象添加一些额外的职责。就扩展而言，Decorator模式比生成子类方式更灵活。 9 Facade 外观 为子系统中的一组几口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 10 Factory Method 工厂方法 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。 11 Flyweight 享元 运用共享技术有效的支持大量细粒度的对象。 12 Interpreter 解释器 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 13 Iterator 迭代子 提供一种方法顺序访问一个聚合对象中各个元素，而不需要暴露该对象的内部表示 14 Mediator 中介者 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可独立的改变它们之间的交互。 15 Memento 备忘录 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 16 Observer 观察者 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新 17 Protorype 原型 用原型实例指定创建对象的种类，并且通过拷贝这个原型老创建新的对象 18 Proxy 代理 为其他对象提供一个代理以控制对这个对象的访问 19 Singleton 单例 保证一个类仅有一个实例，并提供访问它的全局访问点 20 State 状态 允许一个对象在其内部状态改变时改变它的行为。对象看起来是修改了它所属的类 21 Strategy 策略 定义一系列的算法，把他们一个个封装起来，并且他们可以互相替换。本模式使得算法的变化可独立于使用它的客户 22 Template Method 模板方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的接口即可重定义该算法的某些特定步骤 23 Visitor 访问者 表示一个作用与某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作 设计模式分类 分类准则一： 目的。模式是用来完成什么工作 创建型：与对象的创建有关 结构型：处理类或者对象的组合 行为型：处理类或对象怎样交互和怎样分配职责 分类准则二： 范围。模式主要用于类还是对象 类模式：处理类与子类之间的关系，主要通过继承机制实现，编译时期确定，静态 对象模式：处理对象之间的关系，运行时变坏的，动态 类模式： ​ 创建型 - 将对象的部分创建工作延迟到子类 ​ 结构型 - 使用继承机制组合类 ​ 行为型 - 使用继承描述算法和控制流 对象模式： ​ 创建型 - 将创建的工作延迟到另外一个对象 ​ 结构型 - 描述对象组装方式 ​ 行为型 - 描述一组对象如何协作完成单个对象无法完成的任务 设计模式之间的关系（需要深入理解，个人也在不断深入过程中…） 参考 《设计模式：可复用面向对象软件的基础》 Java开发中的23种设计模式详解]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vagrant(2) - 配置文件Vagrantfile]]></title>
    <url>%2F2019%2F06%2F22%2FVagrant-2-%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Vagrantfile%2F</url>
    <content type="text"><![CDATA[Vagrantfile功能介绍根据上文介绍的vagrant原理可知，vagrantfile是虚拟机相关配置文件，这个文件所包含的配置项主要包含 虚拟机配置：网络、内存、主机名、SSH配置、用户名 Vagrant的一些基础配置 Vagrantfile文件 自动生成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The "2" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.Vagrant.configure("2") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://vagrantcloud.com/search. config.vm.box = "centos/7" config.vm.box_version = "1902.01" # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. # config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing "localhost:8080" will access port 80 on the guest machine. # NOTE: This will enable public access to the opened port # config.vm.network "forwarded_port", guest: 80, host: 8080 # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine and only allow access # via 127.0.0.1 to disable public access # config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1" # Create a private network, which allows host-only access to the machine # using a specific IP. # config.vm.network "private_network", ip: "192.168.33.10" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # config.vm.network "public_network" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. # config.vm.synced_folder "../data", "/vagrant_data" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # # config.vm.provider "virtualbox" do |vb| # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = "1024" # end # # View the documentation for the provider you are using for more # information on available options. # Enable provisioning with a shell script. Additional provisioners such as # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the # documentation for more information about their specific syntax and use. # config.vm.provision "shell", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELLend 配置项说明 配置虚拟机主机名 1config.vm.hostname = "jason" 在多个虚拟机中可以使用 vagrant up jason 设置启动指定的服务器 设置 box名称 1config.vm.box = "centos7" 使用 vagrant init boxname 虚拟机网络设置 12345678910# Vagrant的网络连接方式有三种：# NAT : 缺省创建，用于让vm可以通过host访问网络。# host-only : 只有host可以访问vm，其他机器无法访问它。config.vm.network "private_network", ip: "191.168.89.5" # 手动指定ipconfig.vm.network "private_network", type:"dhcp" #dhcp 方式自动生成# bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。config.vm.network "public_network", ip: "191.168.89.3" # 手动指定config.vm.network "public_network" 同步目录 1config.vm.synced_folder "E:/xxx/code", "/home/www/" 前面的路径是host地址，后面地址是vm地址。虚拟机的/vagrant目录默认挂载宿主机的开发目录(可以在进入虚拟机机后，使用df -h 查看)，这是在虚拟机启动时自动挂载的 vm提供者配置 ： virtualbox vmware 等虚拟化工具的相关api配置 通用配置 1234567891011#指定vm-name，也就是virtualbox管理控制台中的虚机名称vb.name = "centos7"# vagrant up启动时，是否自动打开virtual box的窗口，缺省为falsevb.gui = true#指定vm内存，单位为MBvb.memory = "1024"#设置CPU个数vb.cpus = 2 个性化配置（以virtualbox为例） 通过 vb.customize进行配置 具体可自行查询 provision任务：让vagrant在启动虚拟机的时候自动执行 provision 是一组预先指定好的初始化脚本,语法格式 12345678910#单行脚本config.vm.provision 命令字 json格式参数#内联脚本config.vm.provion 命令字 do |s| s.参数名 = 参数值 #外部脚本#在同级目录下创建 script.shconfig.vm.provision "shell", path: "init.sh" 执行的时机 1.第一次执行vagrant up命令 自动执行 2.执行vagrant provision命令 手动触发 3.执行vagrant reload –provision 或者 vagrant up –provision命令 手动触发 4.第一次执行vagrant up 设置–no-provision参数以阻止脚本被执行 参考 Vagrant的配置文件Vagrantfile详解 Vagrant 网络配置 Xshell登录Vagrant方式]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vagrant(1) - Vagrant介绍及基本操作]]></title>
    <url>%2F2019%2F06%2F14%2FVagrant-1-Vagrant%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[vagrant基本工作原理 添加box的时候会生成vagrantfile。这个文件是根据ruby的相关语法定义了虚拟机的配置：网络，操作系统，基础软件，共享目录，启动脚本； 启动虚拟机时候，通过调用虚拟化管理软件(vmware,virtualbox)相关API根据vagrantfile创建基础环境； 调用自定义脚本。调用脚本生成用户自定义需求的软件环境。 vagrant介绍vagrant是一个操作虚拟机的工具.是一个基于Ruby的部署构建工具，用于创建和部署虚拟化开发环境。通过命令和配置文件来管理虚拟机,很快就能完成一套开发环境的部署,并可以打包传播,统一了开发环境,也解决了重复配置环境的麻烦。 vagrant 有以下好处： 建立和删除虚拟机； 配置虚拟机运行参数； 管理虚拟机运行状态； Vagrant通过添加box镜像进行快速部署，部署完毕后可以通过package进行打包分发，避免二次重建环境； Vagrant可以使用puppet、chref等管理工具进行自动化配置部署； Vagrant支持单机模拟多台机器，且支持一个配置文件Vagrantfile就可以跑分布式系统。 vagrant适用的场景 开发环境部署: 快速的构建统一的开发环境，统一管理，分发，通过脚本实现自动化开发环境自动化构建。 测试环境部署：对于测试环节中的集成测试，特别是分布式系统的集成测试，测试环境的搭建也是一个费时费力的工作。Vagrant支持多个实例的部署，可以在单机上创建多个虚拟机实例进行自动化的集成测试。如果单机的测试环境还不够大，也可以将这个工作交给AWS和OpenStack这样的云去完成。 vagrant 环境安装 下载安装VirtualBox : 下载地址 傻瓜式安装步骤 下载并安装vagrant : 下载地址 傻瓜式安装步骤 唯一需要主要的就是版本的一致性，建议选择最新，同时注意宿主机的版本 32 位或者64位 vagrant基本操作 创建工作目录 12mkdir work-dircd work-dir 在空文件夹初始化虚拟机 1vagrant init [box-name] box-name 可以在在线查找需要的box 根据自己的需求进行查找 在初始化完的文件夹内启动虚拟机 1vagrant up 当第一次启动的时候，会进行下载 ssh登录启动的虚拟机 1vagrant ssh 挂起启动的虚拟机 1vagrant suspend 重启虚拟机 1vagrant reload 关闭虚拟机 1vagrant halt 关机，虚拟机停止运行，但是虚拟机实例保留，不销毁，可以理解为是正常的关机； 查找虚拟机的运行状态 1vagrant status 销毁当前虚拟机 1vagrant destroy 销毁虚拟机，虚拟机的实例被销毁; vagrant box 命令 列出本地环境中所有的box 1vagrant box list 添加box到本地vagrant环境 1vagrant box add box-name(box-url) vagrant官网下载package.box 文件，box文件就是一个系统的镜像文件 :boxl官方列表 更新本地环境中指定的box 1vagrant box update box-name 删除本地环境中指定的box 1vagrant box remove box-name 重新打包本地环境中指定的box 1vagrant box repackage box-name 更多的CLI命令可以参考官方文档 参考 征服诱人的Vagrant！ win10搭建Vagrant+VirtualBox环境 Vagrant入门]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 相关配置]]></title>
    <url>%2F2019%2F06%2F05%2Fhexo-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本篇博客主要记录博主通过hexo + next + github过程中的一些配置，既然是配置的东西，我们就需要其中参考了很多现成的轮子。 Hexo评论系统-Valine hexo博客添加搜索功能 hexo的next主题右上角实现fork me on github hexo页脚添加访客人数和总访问量 hexo的next主题个性化教程:打造炫酷网站]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一次跳槽]]></title>
    <url>%2F2019%2F06%2F04%2F%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B7%B3%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[从决定离职，到开始找工作，今天拿到offer，提出离职申请，此刻内心也是比较复杂。 当初从学校出来，校招的时候经过了很久（中间的过程以后再写出来吧 -_- !），最终和其他的公司签订三方，或许是上天冥冥注定，在一个西安的程序员招聘群里面我看到了现在的公司，做大数据的，因为17年时候大数据开始真正热起来，自己在学校期间也研究过这方面的组件，例如 hadoop spark hbase，当然毕业做的就是hbase相关的内容。 因此对这方面也是很有兴趣，虽然给的薪资没有已经签订三方的公司给的高，但是内心觉得能够进入做大数据的公司会更好，所以毅然走上了毁三方的路途，这里我写的有点慷慨激昂，而这个过程也真的是跌宕起伏。上家公司一直卡着，又不给毁约证明，还需要让学校给开证明，而学校方面觉得这事情不归学校管，就这么僵持着，当时对于一个刚出学校大门，走向社会的我，真的很无力无助。而现在的公司有一个应届生培训，是连续两个月，早八晚八，培训的内容也主要是java整个体系，企业文化，职场规划，公司的产品介绍，大数据相关组件介绍等。 从我进入公司，我一直感激当初那个HR姐姐，因为上家没有三方，而下家需要三方，经过沟通，HR允许我先参加公司的集训，三方的事情可以稍微推后。这对于我来说又是多么的幸运。一直心存感激，不可忘怀。 进入公司… 省略工作内容 就这么慢慢的工作着，自己的羽翼也开始丰满，当然对现实也慢慢的不满，我选择离职。在我目前看来，在一个公司工作主要看中两点： 薪资。因为我们工作不是来谈情怀的，我们每个人都需要生活，这是我们工作的第一要义。 平台。公司能给你多大的发展空间，提升自己。对于目前的我而言，自然是希望技术的提升，深度和广度。 很遗憾，这两点我目前都没有看到，况且 而最17-18年西安这轮房价的确涨的有点变态，房租涨，而西安这座古城的薪资体系基本稳定。和学弟了解的情况是，我工作一年的薪资，和人家应届生一样。至于这个数字，不便说出，曾和一个IT老哥聊过，他都对我这个IT从业人员的工资，觉得很匪夷所思。 = = ~ 今天正式提离职，其实在我确定能拿到offer，这个offer其实也不是特别好，毕竟一个外包公司，但是薪资给的还算可以，我内心其实也很犹豫。因为至少从别人的口中了解到外包的情况就是加班多，学不到东西等等。 当然也和自己朋友，好伙计沟通，也许就是此事古难全吧，有得有失。总有一方面有收获。做出这个决定也主要以下两个原因： 不入虎穴焉得虎子，别人口中的终究是别人口中的，而且现在还年轻，即使错了，也不怕，年龄允许我试错。 相对于其他非外包公司，年限卡的严，因此薪资基本和现在差不多了多少，所以薪资算是一方面的收获。 无论在哪里，无论平台如何，个人的努力是必须的。这里记下朋友的一句话：当你选择进入这个公司的时候，你就要想着要走出来，而且是风度翩翩的走出来。 就写这么多了。。。。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[独白]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%8B%AC%E7%99%BD%2F</url>
    <content type="text"><![CDATA[这是本博客的第一篇文章 首先介绍下自己，来自陕西，毕业于一个西安的普通一本，截止这篇文章我已经毕业了22个月，目前在毕业就进的一家传统软件工作供职java开发。 曾经自己也有写写博客，记录学习过程的习惯，具体可以查看我以前的博客，所有的原创内容都是自己的学习笔记，现在看来那些笔记只是自己学习流水账的一个记录，除过大的知识点有印象，比较细节一些的知识点基本都忘了。在毕业之后我也有了解到hexo+github搭建自己的个人博客系统，当时也只是简单的了解到Markdown，不过没有搞出来，也就不了了之。 这次我把这个内容做出来，其实不是自己心血来潮。主要有以下原因： 博客在面试的时候是一个很好的加分项。在我最近面试的一些公司过程中，都有提到过自己的github，以及前面提到过的博客。曾经有个我认为技术氛围很好的公司（在西安这座城市，真正搞技术，公司相对少，大多是外包或者间接性外包，纯属个人观点），那个hr竟然统计了我的博客有多少是原创的和转发的。 博客是自己的对一个技术点的复盘。这点自己现在亲身感受，非常深刻，正如我上面所说我的博客是一个学习流水账的记录，因为没有自己的思考，并且当时的我，对一些知识点也只是停留在使用的层面，比如java.lang.String这个类，有什么方法，都干了些什么，却不知道这个类为什么要这么设计？每个方法具体的实现数据结构和逻辑是怎么样的？ 锻炼自己的书写能力。也看过很多优秀的大佬的公众号，对大佬的文字功底深为佩服，通过文字将自己对某个知识点理解书写下来，久而久之这就是个人的软技能，不单单是做写代码。 当然在这个博客中，我不单单去聊技术，我也想把自己的思考，自己的生活，开心的，吐槽的，都在这里记录下去，或许过了多年以后再来看，会有另一番感受呐？]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
